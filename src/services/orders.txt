import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';
import { TOrder } from '../model/types';


let ws: WebSocket;

function getSocket(url: string) {
    if (!ws) {
        ws = new WebSocket(url)
    };

    return ws;
}

export const api = createApi({
    reducerPath: 'order',
    baseQuery: fetchBaseQuery({
        baseUrl: '/'
    }),
    tagTypes: ['order'],
    endpoints: (builder) => ({
        getAllOrders: builder.query<TOrder | any, number>({
            queryFn: (arg, queryApi, extraOptions, baseQuery) => {
                return { data: {} }
                // return { data: [] }
            },
            async onCacheEntryAdded(
                arg,
                { cacheDataLoaded, cacheEntryRemoved, updateCachedData },
            ) {
                ws = getSocket('wss://norma.nomoreparties.space/orders/all')

                try {
                    await cacheDataLoaded;
                    // the /chat-messages endpoint responded already

                    ws.onopen = (event: Event) => {
                        console.log("Соединение установлено", event)
                    }

                    const listener = (event: MessageEvent) => {
                        console.log('New message...');

                        const data = JSON.parse(event.data)
                        console.log('event -> ', data)

                        updateCachedData((draft) => {
                            console.log('updateCachedData', draft, data);
                            draft.push({ ...data, orders: data.orders.map((order: TOrder) => ({ ...order })) })
                        })
                    }

                    const onOpenWs = () => {
                        console.log('Opening a connection...');

                        ws.send(JSON.stringify({}))
                    }

                    const onCloseWs = () => {
                        console.log('Close connection!');
                    }

                    const onErrorWs = (evt: any) => {
                        console.error(evt);
                    }

                    ws.addEventListener('close', onCloseWs);
                    ws.addEventListener('error', onErrorWs);
                    ws.addEventListener('message', listener);
                    ws.addEventListener('open', onOpenWs);


                } catch {
                    // if cacheEntryRemoved resolved before cacheDataLoaded,
                    // cacheDataLoaded throws
                }

                await cacheEntryRemoved
                // perform cleanup steps once the `cacheEntryRemoved` promise resolves
                ws.close()
            },
        }),
    }),
});

export const { useGetAllOrdersQuery } = api